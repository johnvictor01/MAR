#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <SFE_BMP180.h>
#include <Wire.h>
#include <EEPROM.h>
#include <SD.h>
#include <SPI.h>

File logFile;

Adafruit_MPU6050 mpu;
SFE_BMP180 pressure;

#define PIN_SKIB 14
#define PIN_BUZZER 2 // ESP32 does not have a dedicated DAC pin for tone, this might need a different approach. For now, keeping it as is.
#define PIN_LED_RED 26
#define PIN_LED_GREEN 25
#define PIN_LED_BLUE 27
#define PIN_SPI_CS 5
#define PIN_SPI_MOSI 23
#define PIN_SPI_MISO 19
#define PIN_SPI_SCK 18
#define PIN_SDA 21
#define PIN_SCL 22


#define MAX_ALTITUDE_ADDRESS 0        // Altitude máxima (2 bytes - short int)
#define BASE_PRESSURE_ADDRESS 2       // Pressão base (4 bytes - double)
#define FLIGHT_DATA_START_ADDRESS 6   // Início dos dados de voo (após os 6 bytes usados)
//#define MAX_FLIGHT_DATA_POINTS 250    // Total de pontos (EEPROM: 512 - 6 = 506 bytes / 2 = 253, arredondamos para 250)
#define MAX_FLIGHT_DATA_POINTS 497    // Total de pontos (EEPROM: 1000 - 6 = 994 bytes / 2 = 497)
#define ALTITUDE_SCALE_FACTOR 10.0    // Fator de escala: multiplicar por 10 para preservar 1 casa decimal
#define WINDOW_SIZE 5
#define ASCENT_THRESHOLD 5.0  // Altitude em metros para considerar que o foguete começou a subir
#define DESCENT_DETECTION_THRESHOLD 5.0  // Diferença em metros para detectar descida
#define JUMP_ASCENT 3
#define JUMP_DESCENT 30
#define SKIB_DEACTIVATION_TIME 2000     // Contagem para desativar o SKIB
#define SKIB_BUZZER_DURATION 4000       // Duração do buzzer durante ativação do SKIB (4 segundos)
#define MIN_ALTITUDE_TO_RECORD 5.0      // Altitude mínima para iniciar gravação na EEPROM
#define PRE_FLIGHT_QUEUE_SIZE 4        // Tamanho da fila de pontos pré-voo

// Intervalos para gravação na EEPROM
#define RECORD_INTERVAL_ASCENT 50     // 50ms durante a subida (maior frequência)
#define RECORD_INTERVAL_DESCENT 200   // 200ms durante a descida (menor frequência)

// Intervalos para gravação no SD Card
#define RECORD_INTERVAL_SD 10     // 10ms para gravação no SD Card

// Estados do sistema
enum FlightState {
  PRE_FLIGHT,    // Pré-voo: monitorando altura, bipando, mas não gravando na EEPROM
  ASCENT,        // Ascensão: gravando dados na EEPROM com alta frequência
  RECOVERY       // Recuperação: SKIB ativado, gravando com baixa frequência
};

// Variáveis para gravação na EEPROM
unsigned int recordCounter = 0;        // Contador de registros gravados
unsigned long lastRecordTime = 0;      // Tempo da última gravação

// Variáveis para gravação no SD Card
unsigned long lastSdRecordTime = 0;      // Tempo da última gravação no SD

// Sistema de estados
FlightState currentState = PRE_FLIGHT;

// Fila circular para pontos pré-voo
double preFlightQueue[PRE_FLIGHT_QUEUE_SIZE];
int preFlightQueueIndex = 0;
bool preFlightQueueFull = false;

// Struct para armazenar dados do acelerômetro
struct AccelData {
  float x;
  float y;
  float z;
};

// Fila circular para pontos pré-voo do acelerômetro
AccelData preFlightAccelQueue[PRE_FLIGHT_QUEUE_SIZE];
int preFlightAccelQueueIndex = 0;
bool preFlightAccelQueueFull = false;


double baseline;
double maxAltitude = -999;
bool armado = true;
int jumpSubida = JUMP_ASCENT;
int jumpDescida = JUMP_DESCENT;
int contadorDeTempo = 0;
bool isDescending = false;
bool sensorConnected = false;
bool apogeuDetectado = false; // Flag que indica se já detectamos o apogeu
double smoothedAltitude = 0.0;  // Adicionada como variável global

unsigned long skibActivatedAt = 0;
bool skibDeactivated  = false;

// Variáveis para controle do buzzer durante ativação do SKIB
bool skibBuzzerActive = false;
unsigned long skibBuzzerEndTime = 0;


double alturasSuavizadas[5] = {0, 0, 0, 0, 0};
double altitudeReadings[WINDOW_SIZE] = {0}; // ? inicializando array com escalar?
int currentReadingIndex = 0;
int totalReadings = 0;

// constantes de tempo
// Intervalos em milissegundos do led isWorking
const unsigned long BLINK_INTERVAL = 1000; // ciclo completo de 1 segundo
const unsigned long BLINK_ON_TIME  = 100;  // LED fica ligado 100 ms

// Estado do LED de trabalho
unsigned long previousBlinkMillis = 0;
bool ledWorkingState = LOW;

// ——— Configuração do buzzer periódico ———
const unsigned long BEEP_PERIOD_PREFLIGHT = 3000;  // intervalo entre beeps no pré-voo (ms)
const unsigned long BEEP_PERIOD_ASCENT     = 1000;  // intervalo entre beeps na ascensão (ms)
const unsigned long BEEP_PERIOD_RECOVERY   = 500;   // intervalo entre beeps na recuperação (ms)
const unsigned long BEEP_DURATION  =  400;  // duração de cada beep (ms)
const unsigned int  BEEP_FREQUENCY_PREFLIGHT = 1500;  // frequência para pré-voo (Hz)
const unsigned int  BEEP_FREQUENCY_ASCENT    = 2093;  // frequência para ascensão (Hz) 
const unsigned int  BEEP_FREQUENCY_RECOVERY  = 3136;  // frequência para recuperação (Hz)
const unsigned int  BEEP_FREQUENCY_SKIB      = 2637;  // frequência após ativação do skib (Hz)

unsigned long previousBeepTime = 0;
bool isBeeping = false;

// Estado do buzzer
unsigned long previousBeepMillis = 0;
bool buzzerState = HIGH; // buzzer inativo é HIGH

// Controle de tempo para leitura do sensor (substitui o delay)
const unsigned long SENSOR_READ_INTERVAL = 50;  // 50ms entre leituras do sensor
unsigned long lastSensorReadTime = 0;

void setup() {
  Serial.begin(115200);
  Serial.println(F("Iniciando sistema de altímetro para ESP32"));

  Wire.begin(PIN_SDA, PIN_SCL);

  pinMode(PIN_LED_RED, OUTPUT);
  pinMode(PIN_LED_GREEN, OUTPUT);
  pinMode(PIN_LED_BLUE, OUTPUT);
  pinMode(PIN_BUZZER, OUTPUT);
  pinMode(PIN_SKIB, OUTPUT);

  setRGB(0, 0, 255); // Blue light while booting

  bool sdReady = setupSDCard();
  bool bmpReady = pressure.begin();
  bool mpuReady = setupMPU();
  
  sensorConnected = bmpReady && mpuReady;

  if (sensorConnected && sdReady) {
    Serial.println(F("Sistema pronto. Altimetro, MPU e SD Card OK."));
    setRGB(0, 255, 0); // Green
    delay(1000); // Show green light for 1 second
  } else {
    // Loop indefinitely and blink the error color
    while (1) {
      if (!bmpReady) {
        Serial.println(F("ERRO: Falha no Altimetro (BMP180)!"));
        setRGB(255, 0, 255); // Magenta
      }
      if (!mpuReady) {
        Serial.println(F("ERRO: Falha no Acelerometro (MPU6050)!"));
        setRGB(255, 255, 0); // Yellow
      }
      if (!sdReady) {
        Serial.println(F("ERRO: Falha no SD Card!"));
        setRGB(255, 0, 0); // Red
      }
      delay(500);
      setRGB(0, 0, 0); // Off
      delay(500);
    }
  }

  baseline = readBaselineFromEEPROM();
  resetBaseline();
  
  // Inicializar fila pré-voo
  initializePreFlightQueue();
}

bool setupMPU() {
  Serial.println(F("Initializing MPU6050..."));
  if (!mpu.begin()) {
    Serial.println(F("Failed to find MPU6050 chip"));
    return false;
  }
  Serial.println(F("MPU6050 Found!"));
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  return true;
}

bool setupSDCard() {
  Serial.print(F("Initializing SD card..."));
  // For ESP32, SPI pins are typically managed by the SPIClass instance.
  // You might not need to set pinMode for MOSI, MISO, and SCK if using default HSPI/VSPI pins.
  // However, CS pin needs to be managed manually.
  pinMode(PIN_SPI_CS, OUTPUT);
  digitalWrite(PIN_SPI_CS, HIGH); // Make sure CS is high before starting
  
  SPI.begin(PIN_SPI_SCK, PIN_SPI_MISO, PIN_SPI_MOSI, PIN_SPI_CS);

  if (!SD.begin(PIN_SPI_CS)) {
    Serial.println(F("initialization failed!"));
    return false;
  }
  Serial.println(F("initialization done."));

  // Create a new file
  char fileName[] = "LOG_00.CSV";
  for (uint8_t i = 0; i < 100; i++) {
    fileName[4] = i / 10 + '0';
    fileName[5] = i % 10 + '0';
    if (!SD.exists(fileName)) {
      // Create the file
      logFile = SD.open(fileName, FILE_WRITE);
      break;
    }
  }

  if (logFile) {
    Serial.print(F("Logging to: "));
    Serial.println(fileName);
    logFile.println("Timestamp,Altitude,AccelX,AccelY,AccelZ,State");
    logFile.flush();
    return true;
  } else {
    Serial.println(F("Couldn't create file!"));
    return false;
  }
}

void logDataToSD(double altitude, float ax, float ay, float az) {
  if (logFile) {
    logFile.print(millis());
    logFile.print(",");
    logFile.print(altitude); // Use passed altitude
    logFile.print(",");
    logFile.print(ax);
    logFile.print(",");
    logFile.print(ay);
    logFile.print(",");
    logFile.print(az);
    logFile.print(",");
    logFile.println(getStateString());
  }
}

void loop() {
  unsigned long currentTime = millis();
  
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  if (currentTime - lastSdRecordTime >= RECORD_INTERVAL_SD) {
    lastSdRecordTime = currentTime;
    if (currentState != PRE_FLIGHT) { // Log data to SD card only after PRE_FLIGHT
        logDataToSD(a.acceleration.x, a.acceleration.y, a.acceleration.z);
    }
  }
  
  if (currentTime - lastSensorReadTime >= SENSOR_READ_INTERVAL) {
    lastSensorReadTime = currentTime;
    
    double P = getPressure();
    if (P != -1) {
      double rawAltitude = pressure.altitude(P, baseline);
      smoothedAltitude = getSmoothedAltitude(rawAltitude);

      updateSmoothAltitudeHistory();

      Serial.print(F("Estado: "));
      Serial.print(getStateString());
      Serial.print(F(", Altitude: "));
      Serial.println(smoothedAltitude);
      
      // You can also print accelerometer data here
      // Serial.print(" AccelX: "); Serial.print(a.acceleration.x);
      // Serial.print(" AccelY: "); Serial.print(a.acceleration.y);
      // Serial.print(" AccelZ: "); Serial.println(a.acceleration.z);

      switch (currentState) {
        case PRE_FLIGHT:
          handlePreFlightState(a.acceleration.x, a.acceleration.y, a.acceleration.z);
          break;
        case ASCENT:
          handleAscentState();
          break;
        case RECOVERY:
          handleRecoveryState();
          break;
      }

      checkStateTransitions();

      if (smoothedAltitude > maxAltitude) {
        maxAltitude = smoothedAltitude;
      }

      if (!armado && !skibDeactivated && millis() - skibActivatedAt >= SKIB_DEACTIVATION_TIME) {
        desativarSkib();
        skibDeactivated = true;
        Serial.println(F("SKIB desativado após timeout."));
      }
    }
  }

  updateSkibBuzzer();
  updateStateLED();
  updateBuzzerByState();
}

// Gerencia o buzzer durante a ativação do SKIB
void updateSkibBuzzer() {
  if (skibBuzzerActive) {
    if (millis() >= skibBuzzerEndTime) {
      noTone(PIN_BUZZER);
      skibBuzzerActive = false;
      Serial.println(F("Buzzer do SKIB finalizado."));
    }
  }
}

// Salva a altitude na EEPROM como um short int
void saveAltitudeToEEPROM(double altitude, unsigned int index) {
  short int altitudeScaled;
  if (altitude < -3276.8) {
    altitudeScaled = -32768;
  }
  else if (altitude > 3276.7) {
    altitudeScaled = 32767;
  }
  else {
    altitudeScaled = (short int)(altitude * ALTITUDE_SCALE_FACTOR);
  }
  int address = FLIGHT_DATA_START_ADDRESS + (index * 2);
  EEPROM.put(address, altitudeScaled);
}

// Lê a altitude da EEPROM
double readAltitudeFromEEPROM(unsigned int index) {
  int address = FLIGHT_DATA_START_ADDRESS + (index * 2);
  short int altitudeScaled;
  EEPROM.get(address, altitudeScaled);
  return altitudeScaled / ALTITUDE_SCALE_FACTOR;
}

double getSmoothedAltitude(double newAltitude) {
  altitudeReadings[currentReadingIndex] = newAltitude;
  currentReadingIndex = (currentReadingIndex + 1) % WINDOW_SIZE;

  double sum = 0;
  int count = totalReadings < WINDOW_SIZE ? totalReadings : WINDOW_SIZE;
  for (int i = 0; i < count; i++) {
    sum += altitudeReadings[i];
  }

  if (count > 0) {
    totalReadings++;
    return sum / count;
  }
  return newAltitude; // Return non-smoothed if count is 0
}

double getPressure() {
  char status;
  double T, P;
  status = pressure.startTemperature();
  if (status == 0) return -1;
  delay(status);
  status = pressure.getTemperature(T);
  if (status == 0) return -1;
  status = pressure.startPressure(1);
  if (status == 0) return -1;
  delay(status);
  status = pressure.getPressure(P, T);
  if (status == 0) return -1;
  return P;
}

void ativaSkib() {
  digitalWrite(PIN_SKIB, HIGH);
  setRGB(255, 0, 0); // Red
}

void desativarSkib() {
  digitalWrite(PIN_SKIB, LOW);
}

void saveMaxAltitudeToEEPROM(short int maxAltitudeInt) {
  EEPROM.put(MAX_ALTITUDE_ADDRESS, maxAltitudeInt);
}

double readMaxAltitudeFromEEPROM() {
  short int maxAltitudeInt;
  EEPROM.get(MAX_ALTITUDE_ADDRESS, maxAltitudeInt);
  return maxAltitudeInt / 10.0;
}

double readBaselineFromEEPROM() {
  double savedBaseline;
  EEPROM.get(BASE_PRESSURE_ADDRESS, savedBaseline);
  return (savedBaseline > 0) ? savedBaseline : getPressure();
}

void saveBaselineToEEPROM(double pressure) {
  EEPROM.put(BASE_PRESSURE_ADDRESS, pressure);
}

void setRGB(byte red, byte green, byte blue) {
  // Using ledc for ESP32 PWM control
  ledcWrite(0, red);
  ledcWrite(1, green);
  ledcWrite(2, blue);
}

void setupLEDC() {
  ledcSetup(0, 5000, 8); // channel 0, 5kHz, 8-bit resolution
  ledcAttachPin(PIN_LED_RED, 0);
  ledcSetup(1, 5000, 8); // channel 1, 5kHz, 8-bit resolution
  ledcAttachPin(PIN_LED_GREEN, 1);
  ledcSetup(2, 5000, 8); // channel 2, 5kHz, 8-bit resolution
  ledcAttachPin(PIN_LED_BLUE, 2);
}


void updateBuzzerByState() {
  if (skibBuzzerActive) return;
  
  unsigned long now = millis();
  unsigned long beepPeriod;
  unsigned int beepFrequency;
  
  switch (currentState) {
    case PRE_FLIGHT:
      beepPeriod = BEEP_PERIOD_PREFLIGHT;
      beepFrequency = BEEP_FREQUENCY_PREFLIGHT;
      break;
    case ASCENT:
      beepPeriod = BEEP_PERIOD_ASCENT;
      beepFrequency = BEEP_FREQUENCY_ASCENT;
      break;
    case RECOVERY:
      if (armado) {
        beepPeriod = BEEP_PERIOD_RECOVERY;
        beepFrequency = BEEP_FREQUENCY_RECOVERY;
      } else {
        beepPeriod = BEEP_PERIOD_RECOVERY;
        beepFrequency = BEEP_FREQUENCY_SKIB;
      }
      break;
  }

  if (!isBeeping) {
    if (now - previousBeepTime >= beepPeriod) {
      tone(PIN_BUZZER, beepFrequency);
      isBeeping = true;
      previousBeepTime = now;
    }
  } else {
    if (now - previousBeepTime >= BEEP_DURATION) {
      noTone(PIN_BUZZER);
      isBeeping = false;
      previousBeepTime = now;
    }
  }
}

void updateStateLED() {
  unsigned long currentTime = millis();
  int blinkSpeed;

  switch (currentState) {
    case PRE_FLIGHT:
      blinkSpeed = 1000;
      break;
    case ASCENT:
      blinkSpeed = 250;
      break;
    case RECOVERY:
      blinkSpeed = 1500;
      break;
    default:
      blinkSpeed = 1000;
      break;
  }

  if ((currentTime / blinkSpeed) % 2 == 0) {
    switch (currentState) {
      case PRE_FLIGHT:
        setRGB(0, 0, 255); // Blue
        break;
      case ASCENT:
        setRGB(0, 255, 255); // Cyan
        break;
      case RECOVERY:
        setRGB(255, 165, 0); // Orange
        break;
    }
  } else {
    setRGB(0, 0, 0);
  }
}

bool isAltitudeStable() {
  return abs(alturasSuavizadas[0] - alturasSuavizadas[1]) < 5.0 &&
         abs(alturasSuavizadas[1] - alturasSuavizadas[2]) < 5.0;
}

void resetBaseline() {
  baseline = getPressure();
  saveBaselineToEEPROM(baseline);
  Serial.print(F("Baseline resetado: "));
  Serial.print(baseline);
  Serial.println(F(" m (- nível do mar)."));
}

void activateRecoverySystem() {
  ativaSkib();
  armado = false;
  isDescending = true;
  currentState = RECOVERY;
  setRGB(255, 0, 0); // Red
  skibActivatedAt = millis();
  skibDeactivated  = false;
  saveMaxAltitudeToEEPROM((short int)(maxAltitude * 10));
  
  tone(PIN_BUZZER, BEEP_FREQUENCY_RECOVERY);
  skibBuzzerActive = true;
  skibBuzzerEndTime = millis() + SKIB_BUZZER_DURATION;
  
  Serial.println(F("Sistema de recuperação ativado com buzzer!"));
}

void initializePreFlightQueue() {
  for (int i = 0; i < PRE_FLIGHT_QUEUE_SIZE; i++) {
    preFlightQueue[i] = 0.0;
  }
  preFlightQueueIndex = 0;
  preFlightQueueFull = false;
}

void addToPreFlightQueue(double altitude) {
  preFlightQueue[preFlightQueueIndex] = altitude;
  preFlightQueueIndex = (preFlightQueueIndex + 1) % PRE_FLIGHT_QUEUE_SIZE;
  if (preFlightQueueIndex == 0) {
    preFlightQueueFull = true;
  }
}

// Adiciona um ponto à fila circular pré-voo do acelerômetro
void addToPreFlightAccelQueue(float ax, float ay, float az) {
  preFlightAccelQueue[preFlightAccelQueueIndex].x = ax;
  preFlightAccelQueue[preFlightAccelQueueIndex].y = ay;
  preFlightAccelQueue[preFlightAccelQueueIndex].z = az;
  preFlightAccelQueueIndex = (preFlightAccelQueueIndex + 1) % PRE_FLIGHT_QUEUE_SIZE;
  if (preFlightAccelQueueIndex == 0) {
    preFlightAccelQueueFull = true;
  }
}

void updateSmoothAltitudeHistory() {
  alturasSuavizadas[4] = alturasSuavizadas[3];  
  alturasSuavizadas[3] = alturasSuavizadas[2];  
  alturasSuavizadas[2] = alturasSuavizadas[1];  
  alturasSuavizadas[1] = alturasSuavizadas[0];
  alturasSuavizadas[0] = smoothedAltitude;
}

String getStateString() {
  switch (currentState) {
    case PRE_FLIGHT: return "PRE_FLIGHT";
    case ASCENT: return "ASCENT";
    case RECOVERY: return "RECOVERY";
    default: return "UNKNOWN";
  }
}

void handlePreFlightState(float ax, float ay, float az) {
  // Adicionar altitude atual à fila pré-voo
  addToPreFlightQueue(smoothedAltitude);
  // Adicionar dados do acelerômetro à fila pré-voo
  addToPreFlightAccelQueue(ax, ay, az);
  
  // Não grava na EEPROM durante pré-voo, apenas monitora
  Serial.print(F("Pré-voo - Altitude: "));
  Serial.print(smoothedAltitude);
  Serial.print(F(", AccelX: ")); Serial.print(ax);
  Serial.print(F(", AccelY: ")); Serial.print(ay);
  Serial.print(F(", AccelZ: ")); Serial.println(az);
  Serial.println(F(" m (não gravando na EEPROM)"));
}

void handleAscentState() {
  if (millis() - lastRecordTime >= RECORD_INTERVAL_ASCENT && 
      recordCounter < MAX_FLIGHT_DATA_POINTS) {
    
    saveAltitudeToEEPROM(smoothedAltitude, recordCounter);
    recordCounter++;
    lastRecordTime = millis();
    
    Serial.print(F("ASCENSÃO - Ponto: "));
    Serial.print(recordCounter);
    Serial.print(F(", Tempo: "));
    Serial.print(lastRecordTime);
    Serial.print(F(" ms, Altura: "));
    Serial.print(smoothedAltitude);
    Serial.println(F(" m"));
  }
}

void handleRecoveryState() {
  if (millis() - lastRecordTime >= RECORD_INTERVAL_DESCENT && 
      recordCounter < MAX_FLIGHT_DATA_POINTS) {
    
    saveAltitudeToEEPROM(smoothedAltitude, recordCounter);
    recordCounter++;
    lastRecordTime = millis();
    
    Serial.print(F("RECUPERAÇÃO - Ponto: "));
    Serial.print(recordCounter);
    Serial.print(F(", Tempo: "));
    Serial.print(lastRecordTime);
    Serial.print(F(" ms, Altura: "));
    Serial.print(smoothedAltitude);
    Serial.println(F(" m"));
  }
}

void checkStateTransitions() {
  switch (currentState) {
    case PRE_FLIGHT:
      if (smoothedAltitude >= ASCENT_THRESHOLD) {
        currentState = ASCENT;
        Serial.println(F("TRANSIÇÃO: PRE_FLIGHT -> ASCENT"));
        savePreFlightPointsToEEPROM();
        lastRecordTime = millis();
      }
      break;
      
    case ASCENT:
      if (alturasSuavizadas[0] <= maxAltitude - DESCENT_DETECTION_THRESHOLD && armado) {
        Serial.println(F("TRANSIÇÃO: ASCENT -> RECOVERY"));
        activateRecoverySystem();
        apogeuDetectado = true;
        isDescending = true;
      }
      break;
      
    case RECOVERY:
      break;
  }
}

void savePreFlightPointsToEEPROM() {
  Serial.println(F("Salvando pontos pré-voo na EEPROM e SD Card..."));
  int pointsToSave = preFlightQueueFull ? PRE_FLIGHT_QUEUE_SIZE : preFlightQueueIndex;
  
  for (int i = 0; i < pointsToSave; i++) {
    int queueIndex;
    if (preFlightQueueFull) {
      queueIndex = (preFlightQueueIndex + i) % PRE_FLIGHT_QUEUE_SIZE;
    } else {
      queueIndex = i;
    }
    
    double altitude = preFlightQueue[queueIndex];
    AccelData accel = preFlightAccelQueue[queueIndex]; // Get corresponding accelerometer data
    
    // Save altitude to EEPROM
    saveAltitudeToEEPROM(altitude, recordCounter);
    
    // Log altitude and accelerometer data to SD card
    logDataToSD(altitude, accel.x, accel.y, accel.z);
    
    recordCounter++;
    
    Serial.print(F("Ponto pré-voo #"));
    Serial.print(i);
    Serial.print(F(": Alt="));
    Serial.print(altitude);
    Serial.print(F("m (EEPROM), AccelX="));
    Serial.print(accel.x);
    Serial.print(F(", AccelY="));
    Serial.print(accel.y);
    Serial.print(F(", AccelZ="));
    Serial.println(accel.z);
  }
  
  Serial.print(F("Total de pontos pré-voo salvos: "));
  Serial.println(pointsToSave);
}
